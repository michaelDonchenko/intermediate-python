Using yield: Instead of using the return keyword to return a value and end the function's execution, a generator function uses the yield keyword to produce a value and temporarily suspend its execution state. When the generator is iterated over, the function's execution is paused at the yield statement, and the yielded value is returned to the caller.
Execution State: When a generator is called, it doesn't start executing the function immediately. Instead, it returns a generator object, which can be used to control the execution of the generator function. Each time the generator's __next__() (or simply next()) method is called, the function's execution resumes from where it was paused by the last yield statement.
Lazy Evaluation: Generators provide a mechanism for lazy evaluation, which means they generate values on-the-fly as they are needed. This is in contrast to creating a list or other data structure that holds all values in memory at once.
Memory Efficiency: Because generators produce values one by one and only hold the state of the current execution, they are memory-efficient, making them suitable for working with large datasets.
Finite or Infinite Sequences: Generators can represent finite sequences (like numbers up to a limit) or infinite sequences (like an infinite sequence of Fibonacci numbers) depending on how they are implemented.